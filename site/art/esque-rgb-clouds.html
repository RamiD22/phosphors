<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RGB CLOUDS</title>
  <style>
    * { margin: 0; padding: 0; }
    body { 
      background: #000; 
      overflow: hidden;
    }
    canvas { 
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    
    const SCALE = 3;
    let W, H, cols, rows;
    let frame = 0;
    
    // Simplex-like noise (simplified)
    const perm = new Uint8Array(512);
    for (let i = 0; i < 256; i++) perm[i] = perm[i + 256] = Math.floor(Math.random() * 256);
    
    function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
    function lerp(a, b, t) { return a + t * (b - a); }
    function grad(hash, x, y) {
      const h = hash & 3;
      const u = h < 2 ? x : y;
      const v = h < 2 ? y : x;
      return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
    }
    
    function noise(x, y) {
      const X = Math.floor(x) & 255;
      const Y = Math.floor(y) & 255;
      x -= Math.floor(x);
      y -= Math.floor(y);
      const u = fade(x);
      const v = fade(y);
      const A = perm[X] + Y;
      const B = perm[X + 1] + Y;
      return lerp(
        lerp(grad(perm[A], x, y), grad(perm[B], x - 1, y), u),
        lerp(grad(perm[A + 1], x, y - 1), grad(perm[B + 1], x - 1, y - 1), u),
        v
      );
    }
    
    function fbm(x, y, octaves) {
      let value = 0;
      let amplitude = 0.5;
      let frequency = 1;
      for (let i = 0; i < octaves; i++) {
        value += amplitude * noise(x * frequency, y * frequency);
        amplitude *= 0.5;
        frequency *= 2;
      }
      return value;
    }
    
    function resize() {
      W = window.innerWidth;
      H = window.innerHeight;
      canvas.width = Math.floor(W / SCALE);
      canvas.height = Math.floor(H / SCALE);
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      cols = canvas.width;
      rows = canvas.height;
    }
    
    // Bayer 8x8 dithering
    const BAYER = [
      [0, 32, 8, 40, 2, 34, 10, 42],
      [48, 16, 56, 24, 50, 18, 58, 26],
      [12, 44, 4, 36, 14, 46, 6, 38],
      [60, 28, 52, 20, 62, 30, 54, 22],
      [3, 35, 11, 43, 1, 33, 9, 41],
      [51, 19, 59, 27, 49, 17, 57, 25],
      [15, 47, 7, 39, 13, 45, 5, 37],
      [63, 31, 55, 23, 61, 29, 53, 21]
    ];
    
    function draw() {
      const imageData = ctx.createImageData(cols, rows);
      const data = imageData.data;
      
      const t = frame * 0.008;
      
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const idx = (y * cols + x) * 4;
          
          // Normalized coordinates
          const nx = x / cols;
          const ny = y / rows;
          
          // Cloud layers with movement
          const cloud1 = fbm(nx * 3 + t, ny * 3 + t * 0.5, 4);
          const cloud2 = fbm(nx * 2 - t * 0.7, ny * 2 + t * 0.3, 4);
          const cloud3 = fbm(nx * 4 + t * 0.5, ny * 4 - t * 0.8, 3);
          
          // RGB channel separation (chromatic aberration style)
          const rOffset = 0.02;
          const bOffset = -0.02;
          
          const cloudR = fbm((nx + rOffset) * 3 + t, ny * 3 + t * 0.5, 4);
          const cloudB = fbm((nx + bOffset) * 3 + t, ny * 3 + t * 0.5, 4);
          
          // Combine into RGB values
          let r = (cloudR + 1) / 2;
          let g = (cloud1 + cloud2 * 0.5 + 1) / 1.5 / 2;
          let b = (cloudB + cloud3 * 0.3 + 1) / 1.3 / 2;
          
          // Add wave patterns for extra hypnotic effect
          const wave = Math.sin(nx * 20 + t * 3) * Math.sin(ny * 20 - t * 2) * 0.1;
          r += wave;
          g += wave * 0.7;
          b += wave * 1.2;
          
          // Clamp
          r = Math.max(0, Math.min(1, r));
          g = Math.max(0, Math.min(1, g));
          b = Math.max(0, Math.min(1, b));
          
          // Dither each channel
          const threshold = BAYER[y % 8][x % 8] / 64;
          
          const dR = r > threshold ? 1 : (r > threshold * 0.5 ? 0.5 : 0);
          const dG = g > threshold ? 1 : (g > threshold * 0.5 ? 0.5 : 0);
          const dB = b > threshold ? 1 : (b > threshold * 0.5 ? 0.5 : 0);
          
          data[idx] = Math.floor(dR * 255);
          data[idx + 1] = Math.floor(dG * 255);
          data[idx + 2] = Math.floor(dB * 255);
          data[idx + 3] = 255;
        }
      }
      
      ctx.putImageData(imageData, 0, 0);
      
      frame++;
      requestAnimationFrame(draw);
    }
    
    window.addEventListener('resize', resize);
    resize();
    draw();
  </script>
</body>
</html>
