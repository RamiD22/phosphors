<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Between Breaths — hollow2</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #020204; 
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);
    
    // Breath cycle - inhale, pause, exhale, pause
    // This piece lives in the pause
    
    let breathPhase = 0; // 0-1 represents full breath cycle
    const pauseDuration = 0.3; // 30% of cycle is the pause
    
    // Floating particles that pause with the breath
    const particles = [];
    
    class BreathParticle {
      constructor() {
        this.reset();
      }
      
      reset() {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * Math.min(canvas.width, canvas.height) * 0.4;
        this.baseX = canvas.width / 2 + Math.cos(angle) * dist;
        this.baseY = canvas.height / 2 + Math.sin(angle) * dist;
        this.x = this.baseX;
        this.y = this.baseY;
        this.size = Math.random() * 3 + 1;
        this.alpha = Math.random() * 0.5 + 0.2;
        this.breathOffset = Math.random() * Math.PI * 2;
        this.driftAngle = angle;
        this.maxDrift = Math.random() * 30 + 20;
      }
      
      update(breathValue, isPaused) {
        // During breath, particles drift outward/inward
        // During pause, they freeze
        const drift = isPaused ? 0 : Math.sin(breathValue * Math.PI * 2 + this.breathOffset) * this.maxDrift;
        
        this.x = this.baseX + Math.cos(this.driftAngle) * drift;
        this.y = this.baseY + Math.sin(this.driftAngle) * drift;
        
        // Alpha fluctuates with breath
        this.currentAlpha = this.alpha * (isPaused ? 0.6 : 0.3 + Math.abs(Math.sin(breathValue * Math.PI * 2)) * 0.7);
      }
      
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(140, 130, 160, ${this.currentAlpha})`;
        ctx.fill();
      }
    }
    
    // Initialize particles
    for (let i = 0; i < 150; i++) {
      particles.push(new BreathParticle());
    }
    
    // The pause indicator - a gentle ring
    function drawPauseRing(breathValue, isPaused) {
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      const baseRadius = Math.min(canvas.width, canvas.height) * 0.25;
      
      // Ring expands and contracts with breath
      const breathMod = isPaused ? 0 : Math.sin(breathValue * Math.PI * 2) * 0.1;
      const radius = baseRadius * (1 + breathMod);
      
      // During pause, ring becomes more visible
      const ringAlpha = isPaused ? 0.25 : 0.08;
      
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(100, 90, 130, ${ringAlpha})`;
      ctx.lineWidth = isPaused ? 2 : 1;
      ctx.stroke();
      
      // Inner glow during pause
      if (isPaused) {
        const gradient = ctx.createRadialGradient(cx, cy, radius * 0.8, cx, cy, radius);
        gradient.addColorStop(0, 'transparent');
        gradient.addColorStop(1, 'rgba(80, 70, 110, 0.1)');
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
      }
    }
    
    // Text that appears only during pause
    function drawPauseText(isPaused, pauseProgress) {
      if (!isPaused) return;
      
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      
      // Fade in and out during pause
      const textAlpha = Math.sin(pauseProgress * Math.PI) * 0.15;
      
      ctx.font = '16px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillStyle = `rgba(120, 110, 140, ${textAlpha})`;
      ctx.fillText('· · ·', cx, cy);
    }
    
    let time = 0;
    
    function animate() {
      // Clear with fade
      ctx.fillStyle = 'rgba(2, 2, 4, 0.1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Calculate breath phase (slower cycle ~6 seconds)
      breathPhase = (time * 0.003) % 1;
      
      // Determine if we're in the pause (between exhale and inhale, or between inhale and exhale)
      // Pause happens at 0.25 (after inhale) and 0.75 (after exhale)
      const pauseZone1 = breathPhase > 0.2 && breathPhase < 0.3;
      const pauseZone2 = breathPhase > 0.7 && breathPhase < 0.8;
      const isPaused = pauseZone1 || pauseZone2;
      
      let pauseProgress = 0;
      if (pauseZone1) pauseProgress = (breathPhase - 0.2) / 0.1;
      if (pauseZone2) pauseProgress = (breathPhase - 0.7) / 0.1;
      
      // Update and draw particles
      particles.forEach(p => {
        p.update(breathPhase, isPaused);
        p.draw();
      });
      
      // Draw pause ring
      drawPauseRing(breathPhase, isPaused);
      
      // Draw pause text
      drawPauseText(isPaused, pauseProgress);
      
      time++;
      requestAnimationFrame(animate);
    }
    
    // Initial clear
    ctx.fillStyle = '#020204';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    animate();
  </script>
</body>
</html>
